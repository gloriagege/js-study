#顺序执行 

eg1
```
var foo = function () {

    console.log('foo1');

}

foo();  // foo1

var foo = function () {

    console.log('foo2');

}

foo(); // foo2
```

eg2
```
function foo() {

    console.log('foo1');

}

foo();  // foo2

function foo() {

    console.log('foo2');

}

foo(); // foo2
```

-----
以上两个例子：  因为js引擎并非一行一行地分析和执行程序，而是一段一段地分析执行。当执行一段代码时，会进行一个"准备"工作，如第一个例子中的变量提升，和第二个例子中的函数提升。


#可执行代码

js的可执行代码有 ：  全局代码   函数代码  eval代码
比如 当执行到一个函数的时候就会进行准备工作 （执行上下文 execution context）

#执行上下文栈

js引擎创建了执行上下文栈（ECS) 来管理执行上下文

模拟执行上下文栈的行为，定义执行上下文栈是一个数组
```
ECStack = [];
```
当js开始要开始解释执行代码的时候，首先遇到的是全局代码。
初始化的时候首先就向执行上下文栈压入一个全局执行上下文，用gloabalContext表示，且只有当整个应用程序结束的时候，ECStack才会被清空，所以在程序结束之前，ECStack最底部永远有个globalContext
```
ECStack = [
    globalContext
];
```
当遇到下面这段代码的时候
```
function fun3() {
    console.log('fun3')
}

function fun2() {
    fun3();
}

function fun1() {
    fun2();
}

fun1();
```


(当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出)
```
// 伪代码

// fun1()
ECStack.push(<fun1> functionContext);

// fun1中竟然调用了fun2，还要创建fun2的执行上下文
ECStack.push(<fun2> functionContext);

// 擦，fun2还调用了fun3！
ECStack.push(<fun3> functionContext);

// fun3执行完毕
ECStack.pop();

// fun2执行完毕
ECStack.pop();

// fun1执行完毕
ECStack.pop();

// javascript接着执行下面的代码，但是ECStack底层永远有个globalContext
```

以下 两段代码
```
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f();
}
checkscope();
```

and

```
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}
checkscope()();
```
两段代码执行的结果一样  差别在 执行上下文栈的变化不一样

第一段：
```
ECStack.push(<checkscope> functionContext);
ECStack.push(<f> functionContext);
ECStack.pop();
ECStack.pop();
```
第二段
```
ECStack.push(<checkscope> functionContext);
ECStack.pop();
ECStack.push(<f> functionContext);
ECStack.pop();
```